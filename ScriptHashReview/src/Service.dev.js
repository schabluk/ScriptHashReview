import axios, { get } from 'axios'
import faker from 'faker'
import Tokens from './Tokens'

/*
 * Axios config.
 */
const config = {
  mode: 'cors',
  headers: {
    'Content-Type': 'application/json;charset=UTF-8',
    'Accept': 'application/json',
  },
  timeout: 3000,
  validateStatus (status) {
    return status >= 200 && status < 300
  },
}

/*
 * Only 'data' property will be returned from the request. This will simplify
 * data processing, as it won't be neccesary to call .then()
 * to return the request.data.
 * See: https://github.com/axios/axios#response-schema
 */
axios.interceptors.response.use(({data}) => data)

// Fake request delay.
const Delay = time => new Promise(resolve => setTimeout(() => resolve(), time))

const randomIntFromInterval = (min, max) => {
  return Math.floor(Math.random()*(max-min+1)+min)
}

const { finance, random, lorem } = faker

const tokens = Object.values(Tokens).map(
  ({ companyName: name, symbol, image, networks }) => ({
    name,
    symbol,
    image,
    hash: networks[1].hash
  })
)

/*
 * Service Bus.
 */
const Service = {
  // Tokens API.
  notifications: {
    async tokens () {
      try {
        return await get(`http://notifications.neeeo.org/v1/tokens`, config)
      } catch ({message}) {
        throw new Error(`Failed to fetch tokens data: ${message}`)
      }
    },
  },
  // Fake data generated by Faker.js.
  contract: {
    async addReview (reviewOwner, scriptHash, rating, comment) {
      try {
        return await Delay(500).then(() => random.boolean())
      } catch (error) {
        throw new Error(`Fake API addReview: ${error.message}`)
      }
    },
    async getReview(reviewOwner, scriptHash) {
      try {
        return await Delay(500).then(() => ({
          reviewOwner: finance.bitcoinAddress(),
          scriptHash: `${random.uuid()}`.replace(/-/g, ''),
          rating: randomIntFromInterval(0, 10),
          comment: lorem.paragraph()
        }));
      } catch (error) {
        throw new Error(`Fake API getReview: ${error.message}`);
      }
    },
    async editReview (reviewOwner, scriptHash, rating, comment) {
      try {
        return await Delay(500).then(() => random.boolean())
      } catch (error) {
        throw new Error(`Fake API editReview: ${error.message}`)
      }
    },
    async getNumberOfReviewsFrom (reviewOwner) {
      try {
        return await Delay(500).then(() => randomIntFromInterval(3, 9))
      } catch (error) {
        throw new Error(`Fake API getNumberOfReviewsFrom: ${error.message}`)
      }
    },
    async getNumberOfReviewsFor (scriptHash) {
      try {
        return await Delay(500).then(() => randomIntFromInterval(5, 20))
        // return await Delay(500).then(() => 0) // No reviews.
      } catch (error) {
        throw new Error(`Fake API getNumberOfReviewsFor: ${error.message}`)
      }
    },
    getReviewFromAddress (reviewOwner, number) {
      return this.getReview()
    },
    getReviewForScriptHash (scriptHash, number) {
      return this.getReview()
    },
    async getNumberOfTokens () {
      try {
        return await Delay(500).then(() => tokens.length)
      } catch (error) {
        throw new Error(`Fake API getReviewFromAddress: ${error.message}`)
      }
    },
    async getToken (number) {
      try {
        return await Delay(500).then(() => {
          const { hash, name, symbol, image } = tokens[number]
          return {
            hash,
            name,
            symbol,
            supply: 1000000000,
            image,
          }
        });
      } catch (error) {
        throw new Error(`Fake API getReview: ${error.message}`);
      }
    },
    async getTokens () {
      try {
        return await this.getNumberOfTokens().then((length = 0) => Promise.all(
          Array.from({length}, (v, k) => this.getToken(k))
        ))
      } catch (error) {
        throw new Error(`Fake API getTokens: ${error.message}`);
      }
    },
    async getReviews (scriptHash) {
      try {
        return await this.getNumberOfReviewsFor(scriptHash).then(
          (length = 0) => Promise.all(
            Array.from(
              {length}, (v, k) => this.getReviewForScriptHash(scriptHash, k)
            )
          )
        )
      } catch (error) {
        throw new Error(`Fake API getTokens: ${error.message}`);
      }
    }
  },
  // nOS native API.
  nos: {
    async getAddress () {
      try {
        return await Delay(500).then(() => finance.bitcoinAddress())
      } catch (error) {
        throw new Error(`nOS API getAddress: ${error.message}`)
      }
    },
    async getBalance (scriptHash) {
      try {
        return await Delay(500).then(() => Math.random() * 100)
      } catch (error) {
        throw new Error(`nOS API getAddress: ${error.message}`)
      }
    },
    async send (amount, scriptHash, receiver) {
      try {
        return await Delay(900).then(() => {
          return `${random.uuid()}${random.uuid()}`.replace(/-/g, '')
        })
      } catch (error) {
        throw new Error(`nOS API send: ${error.message}`)
      }
    },
  },
}

export default Service
