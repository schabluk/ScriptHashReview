import axios, { get } from 'axios'
import nOS from '@nosplatform/api-functions'
import { u, wallet } from '@cityofzion/neon-js'
import faker from 'faker'

import Tokens from './Tokens'

window.u = u
window.wallet = wallet

/*
 * Axios config.
 */
const config = {
  mode: 'cors',
  headers: {
    'Content-Type': 'application/json;charset=UTF-8',
    'Accept': 'application/json',
  },
  timeout: 3000,
  validateStatus (status) {
    return status >= 200 && status < 300
  },
}

/*
 * Only 'data' property will be returned from the request. This will simplify
 * data processing, as it won't be neccesary to call .then()
 * to return the request.data.
 * See: https://github.com/axios/axios#response-schema
 */
axios.interceptors.response.use(({data}) => data)

// Fake request delay.
const Delay = time => new Promise(resolve => setTimeout(() => resolve(), time))

const randomIntFromInterval = (min, max) => {
  return Math.floor(Math.random()*(max-min+1)+min)
}

const { finance, random, lorem } = faker

const tokens = Object.values(Tokens).map(
  ({ companyName: name, symbol, image, networks }) => ({
    name,
    symbol,
    image,
    hash: networks[1].hash
  })
)

/*
 * Smart Contract Script Hash.
 */
const contractHash = 'a6edabd7330b312fdd94755a4c06b3679d4ebfb4'
const contractAddress = 'AK2nJJpJr6o664CWJKi1QRXjqeic2zRp8y'

/*
 * Service Bus.
 */
const Service = {
  // Tokens API.
  notifications: {
    async tokens () {
      try {
        return await get(`http://notifications.neeeo.org/v1/tokens`, config)
      } catch ({message}) {
        throw new Error(`Failed to fetch tokens data: ${message}`)
      }
    },
  },
  // Fake data generated by Faker.js.
  contract: {
    async invoke (args, operation) {
      try {
        // const encodeArgs = args => args.map(arg => {
        //   if (typeof arg === 'string') return u.str2hexstring(arg)
        //   if (typeof arg === 'number') return u.int2hex(arg)
        //   if (Array.isArray(arg)) return encodeArgs(arg)
        //   if (wallet.isAddress(arg)) {
        //     return u.reverseHex(wallet.getScriptHashFromAddress(arg))
        //   }
        //   return arg
        // })

        // return await nOS.testInvoke({
        //   scriptHash: contractHash,
        //   operation,
        //   args: encodeArgs(args),
        //   encodeArgs: false
        // })
        return await nOS.testInvoke({
          scriptHash: contractHash, operation, args
        })
        .then(data => {
          const { stack, state } = data

          // console.log('state')
          // console.log(JSON.stringify(state))
          // console.log(JSON.stringify(stack))
          // console.log('-------------------')

          const print = stack =>
            stack.map(o => {
              if (Array.isArray(o.value)) {
                print(o.value)
              } else {
                if (wallet.isAddress(wallet.getAddressFromScriptHash(u.reverseHex(o.value)))) {
                  console.log(wallet.getAddressFromScriptHash(u.reverseHex(o.value)))
                } else {
                  console.log(u.hexstring2str(o.value))
                }
              }
            })

          print(stack)

          return stack
        })
        .catch(error => console.error(error))
      } catch (error) {
        throw new Error(`Operation '${operation}': ${error.message}`)
      }
    },
    test (address, scriptHash) {
      return this.invoke(Array.from(arguments), 'addReview')
    },
    async addReview (reviewOwner, scriptHash, rating, comment) {
      try {
        return await Delay(500).then(() => random.boolean())
      } catch (error) {
        throw new Error(`Fake API addReview: ${error.message}`)
      }
    },
    async getReview(reviewOwner, scriptHash) {
      try {
        return await Delay(500).then(() => ({
          reviewOwner: finance.bitcoinAddress(),
          scriptHash: `${random.uuid()}`.replace(/-/g, ''),
          rating: randomIntFromInterval(0, 10),
          comment: lorem.paragraph()
        }));
      } catch (error) {
        throw new Error(`Fake API getReview: ${error.message}`);
      }
    },
    async editReview (reviewOwner, scriptHash, rating, comment) {
      try {
        return await Delay(500).then(() => random.boolean())
      } catch (error) {
        throw new Error(`Fake API editReview: ${error.message}`)
      }
    },
    async getNumberOfReviewsFrom (reviewOwner) {
      try {
        return await Delay(500).then(() => randomIntFromInterval(3, 9))
      } catch (error) {
        throw new Error(`Fake API getNumberOfReviewsFrom: ${error.message}`)
      }
    },
    async getNumberOfReviewsFor (scriptHash) {
      try {
        return await Delay(500).then(() => randomIntFromInterval(5, 20))
        // return await Delay(500).then(() => 0) // No reviews.
      } catch (error) {
        throw new Error(`Fake API getNumberOfReviewsFor: ${error.message}`)
      }
    },
    getReviewFromAddress (reviewOwner, number) {
      return this.getReview()
    },
    getReviewForScriptHash (scriptHash, number) {
      return this.getReview()
    },
    async getNumberOfTokens () {
      try {
        return await Delay(500).then(() => tokens.length)
      } catch (error) {
        throw new Error(`Fake API getReviewFromAddress: ${error.message}`)
      }
    },
    async getToken (number) {
      try {
        return await Delay(500).then(() => {
          const { hash, name, symbol, image } = tokens[number]
          return {
            hash,
            name,
            symbol,
            supply: 1000000000,
            image,
          }
        });
      } catch (error) {
        throw new Error(`Fake API getReview: ${error.message}`);
      }
    },
    async getTokens () {
      try {
        return await this.getNumberOfTokens().then((length = 0) => Promise.all(
          Array.from({length}, (v, k) => this.getToken(k))
        ))
      } catch (error) {
        throw new Error(`Fake API getTokens: ${error.message}`);
      }
    },
    async getReviews (scriptHash) {
      try {
        return await this.getNumberOfReviewsFor(scriptHash).then(
          (length = 0) => Promise.all(
            Array.from(
              {length}, (v, k) => this.getReviewForScriptHash(scriptHash, k)
            )
          )
        )
      } catch (error) {
        throw new Error(`Fake API getTokens: ${error.message}`);
      }
    }
  },
  // nOS native API.
  nos: {
    async getAddress () {
      try {
        return await nOS.getAddress()
      } catch (error) {
        throw new Error(`nOS API getAddress: ${error.message}`)
      }
    },
    async getBalance (scriptHash) {
      try {
        return await nOS.getBalance({asset: scriptHash})
      } catch (error) {
        throw new Error(`nOS API getAddress: ${error.message}`)
      }
    },
    async send (amount, scriptHash, receiver) {
      try {
        return await nOS.send({amount, asset: scriptHash, receiver})
      } catch (error) {
        throw new Error(`nOS API send: ${error.message}`)
      }
    },
  },
}

export default Service
